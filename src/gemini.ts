import { GoogleGenAI } from '@google/genai';
import { Theme, Style } from './types';
import { config } from './config';

let genAIInstance: GoogleGenAI | undefined;

export function getGoogleGenAIInstance(): GoogleGenAI {
  if (!genAIInstance) {
    const apiKey = config.gemini.apiKey;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is not set in environment variables.');
    }
    genAIInstance = new GoogleGenAI({apiKey: apiKey});
  }
  return genAIInstance;
}

/**
 * Generates a blessing text using the Google Gemini API based on the provided theme and style.
 * The generated text will be between a configured min and max length.
 * @param {Theme} theme - The selected theme.
 * @param {Style} style - The selected style.
 * @returns {Promise<string>} A promise that resolves to the generated blessing text.
 */
export async function generateBlessingText(theme: Theme, style: Style): Promise<string> {
  const genAI = getGoogleGenAIInstance();
  const prompt = config.gemini.promptTemplate
    .replace('{theme}', theme.name)
    .replace('{style}', style.name)
    .replace('{minLength}', String(config.gemini.textMinLength))
    .replace('{maxLength}', String(config.gemini.textMaxLength));

  let attempts = 0;
  const maxAttempts = config.gemini.maxAttempts;

  while (attempts < maxAttempts) {
    try {
      const result = await genAI.models.generateContent({ model: config.gemini.model, contents: prompt });
      const blessingText = result.text ? result.text.trim() : '';

      if (blessingText.length >= config.gemini.textMinLength && blessingText.length <= config.gemini.textMaxLength) {
        return blessingText;
      } else {
        console.warn(`Generated text length is out of bounds: "${blessingText}" (${blessingText.length} chars). Retrying...`);
      }
    } catch (error: any) {
      console.error(`Attempt ${attempts + 1} failed:`, error);
      // Check for quota exceeded error
      if (error.message && error.message.includes('RESOURCE_EXHAUSTED')) {
        throw new Error('GEMINI_QUOTA_EXCEEDED'); // Custom error to be caught by webhook handler
      }
      // if (error.message.includes('API_KEY')) {
      //   throw new Error('GEMINI_API_KEY is not configured correctly.');
      // }
    }
    attempts++;
  }

  console.error('Failed to generate a valid blessing text after multiple attempts.');

  // Fallback to a generic blessing generated by Gemini
  try {
    console.log('Attempting to generate a generic fallback blessing...');
    // This fallback prompt could also be a future config
    const fallbackPrompt = config.gemini.fallbackPromptTemplate
      .replace('{minLength}', String(config.gemini.textMinLength))
      .replace('{maxLength}', String(config.gemini.textMaxLength));
    const result = await genAI.models.generateContent({ model: config.gemini.model, contents: fallbackPrompt });
    const blessingText = result.text ? result.text.trim() : '';

    if (blessingText.length >= config.gemini.textMinLength && blessingText.length <= config.gemini.textMaxLength) {
      return blessingText;
    }
  } catch (error) {
    console.error('Failed to generate fallback blessing:', error);
  }

  // Final fallback to a hardcoded default blessing (could also be a config)
  return config.gemini.finalFallbackText;
}

import { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai';
import { Theme, Style } from './types';
import { config } from './config';

let generativeModel: GenerativeModel | undefined;

function getGenerativeModel(): GenerativeModel {
  if (!generativeModel) {
    const apiKey = config.gemini.apiKey;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is not set in environment variables.');
    }
    const genAI = new GoogleGenerativeAI(apiKey);
    const modelName = config.gemini.model;
    generativeModel = genAI.getGenerativeModel({ model: modelName });
  }
  return generativeModel;
}

/**
 * Generates a blessing text using the Google Gemini API based on the provided theme and style.
 * The generated text will be between a configured min and max length.
 * @param {Theme} theme - The selected theme.
 * @param {Style} style - The selected style.
 * @returns {Promise<string>} A promise that resolves to the generated blessing text.
 */
export async function generateBlessingText(theme: Theme, style: Style): Promise<string> {
  const model = getGenerativeModel();
  const prompt = config.gemini.promptTemplate
    .replace('{theme}', theme.name)
    .replace('{style}', style.name)
    .replace('{minLength}', String(config.gemini.textMinLength))
    .replace('{maxLength}', String(config.gemini.textMaxLength));

  let attempts = 0;
  const maxAttempts = config.gemini.maxAttempts;

  while (attempts < maxAttempts) {
    try {
      const result = await model.generateContent(prompt);
      const response = await result.response;
      const blessingText = response.text().trim();

      if (blessingText.length >= config.gemini.textMinLength && blessingText.length <= config.gemini.textMaxLength) {
        return blessingText;
      } else {
        console.warn(`Generated text length is out of bounds: "${blessingText}" (${blessingText.length} chars). Retrying...`);
      }
    } catch (error: any) {
      console.error(`Attempt ${attempts + 1} failed:`, error);
      if (error.message.includes('API_KEY')) {
        throw new Error('GEMINI_API_KEY is not configured correctly.');
      }
    }
    attempts++;
  }

  console.error('Failed to generate a valid blessing text after multiple attempts.');

  // Fallback to a generic blessing generated by Gemini
  try {
    console.log('Attempting to generate a generic fallback blessing...');
    // This fallback prompt could also be a future config
    const fallbackPrompt = config.gemini.fallbackPromptTemplate
      .replace('{minLength}', String(config.gemini.textMinLength))
      .replace('{maxLength}', String(config.gemini.textMaxLength));
    const result = await model.generateContent(fallbackPrompt);
    const response = await result.response;
    const blessingText = response.text().trim();

    if (blessingText.length >= config.gemini.textMinLength && blessingText.length <= config.gemini.textMaxLength) {
      return blessingText;
    }
  } catch (error) {
    console.error('Failed to generate fallback blessing:', error);
  }

  // Final fallback to a hardcoded default blessing (could also be a config)
  return config.gemini.finalFallbackText;
}
